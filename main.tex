% --- Classes do documento
\documentclass[article,11pt,oneside,a4paper,english,brazil,sumario=tradicional]{abntex2}

% --- Pacotes fundamentais
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{indentfirst}
\usepackage{nomencl}
\usepackage{color}
\usepackage{graphicx}
\usepackage{microtype}
\usepackage{float}

% --- Pacotes de citações
\usepackage[brazilian,hyperpageref]{backref}
\usepackage[alf]{abntex2cite}

% --- Configurações do pacote backref
\renewcommand{\backrefpagesname}{Citado na(s) página(s):~}
% Texto padrão antes do número das páginas
\renewcommand{\backref}{}
% Define os textos da citação
\renewcommand*{\backrefalt}[4]{
    \ifcase #1 %
         %
    \or
        Citado na página #2.%
    \else
        Citado #1 vezes nas páginas #2.%
    \fi}%

% --- Capa e folha de rosto
\titulo{Artigo científico sobre banco de dados}
\autor {Antonio Marcos Siqueira \\ Guilherme Banzati Viana Ribeiro}
\local{Brasil}
\data{24 de Junho de 2022}

% --- Configurações de aparência do PDF final
\definecolor{blue}{RGB}{41,5,195}

% --- Informações do PDF
\makeatletter
\hypersetup{
    pdftitle={\@title}, 
	pdfauthor={\@author},
    pdfsubject={Modelo de artigo científico com abnTeX2},
	colorlinks=true,
    linkcolor=blue,
    citecolor=blue,
    filecolor=magenta,
	urlcolor=blue,
	bookmarksdepth=4
}

\makeatother

\makeindex

% --- Alterar as margens padrões
\setlrmarginsandblock{3cm}{3cm}{*}
\setulmarginsandblock{3cm}{3cm}{*}
\checkandfixthelayout


% --- Espaçamentos entre linhas e parágrafos
\setlength{\parindent}{1.3cm}
\setlength{\parskip}{0.2cm}
\SingleSpacing

% --- Início do documento
\begin{document}
\frenchspacing

\maketitle

% --- Resumo
\begin{resumo}

Artigo cientifico sobre o uso de Views, Triggers, Procedimentos e Joins na linguagem SQL no trabalho, e manipulação, de bancos de dados relacionais.
\vspace{\onelineskip}

\noindent
\end{resumo}

\textual

% --- Introdução
\section{Introdução}

\addcontentsline{toc}{section}{Introdução}

A linguagem SQL (Struct Query Language, ou “Linguagem de Consulta Estruturada”) é uma linguagem padrão para a manipulação de dados dentro de um sistema de gerenciamento de banco de dados. \\
Ela possibilita o armazenamento, organização, atualização e exclusão de informações dentro de um determinado banco de dados, e é uma linguagem declarativa e que não necessita de profundos conhecimentos de programação para que alguém possa começar a manipula-la. \\
Neste artigo científico, sera explicado as definições, aplicações e exemplos práticos seguintes tópicos contidos na linguagem SQL: Views, Triggers, Procedimentos e Join (junções); além de ser explicados e analisados cenários em que esses tópicos podem, ou não, serem aplicados.

% --- Tópico: Views
\section{Views}

\subsection{Definição}

Em teoria de banco de dados, uma view é um conjunto resultado de uma consulta armazenada sobre os dados, as linhas e colunas da view são geradas dinamicamente no momento em que é feita uma referência a ela.

\subsection{Para que serve}

Uma view é uma maneira alternativa de observação de dados de uma ou mais tabelas, que compõem uma base de dados. Então ela pode ser considerada como uma tabela virtual (ou uma consulta armazenada). \\
Sendo assim, as views nos possibilitam mais que simplesmente ''visualizar dados'', pois elas podem ser implementadas também com algumas aplicações de restrição

\subsection{Para que deve ser aplicado}

As views podem ser usadas em casos como: criar uma restrição entre os usuários e os dados, criar uma restrição entre os usuários e os domínios, associar vários domínios formando uma única entidade e agregar informações, em vez de fornecer maiores detalhes do banco de dados.

\subsection{Locais onde não deve ser aplicado}

Existem alguns locais que as views não devem ser aplicadas, elas escondem uma complexidade da query, podendo enganar o desenvolvedor quanto à performance necessária para acessar determinada informação especifica. \\
Também pode ser mais complexo quando views usam outras views. Em alguns casos, o usuário pode estar fazendo consultas desnecessárias (sem saber disso) e de forma muito intensiva. \\
As views também podem ser ''mal utilizadas'' criando camadas extras, e assim, mais objetos para serem administrados, em alguns casos, isso pode limitar exageradamente o que o usuário pode acessar impedindo certas tarefas. \\

\subsection{Exemplos práticos}

Um exemplo prático sobre um uso de uma view: abaixo vemos uma view criada para facilitar o acesso de vendas e produtos de um determinado banco de dados.

\begin{verbatim}
    CREATE VIEW vwVendas AS
    SELECT * FROM Vendas V
    JOIN Clientes C ON V.Cliente_id = C.id_Cliente
    JOIN Produtos P ON V.Produto_id = P.id_Produto
    GO
\end{verbatim}

A view criada no exemplo anterior pode ser executada da seguinte forma

\begin{verbatim}
    SELECT * FROM vwVendas
\end{verbatim}

% --- Tópico: Triggers
\section{Triggers}

\subsection{Definição}

Os triggers (gatilhos) definem uma estrutura do banco de dados que funciona, como o nome sugere, como uma função que é disparada mediante alguma ação.
Geralmente essas ações que disparam os triggers são alterações nas tabelas por meio de operações de inserção, exclusão e atualização de dados (insert, delete e update). \\
Um gatilho está diretamente relacionado a uma tabela, sempre que uma dessas ações é efetuada sobre determinada tabela, é possível dispará-lo para executar alguma tarefa.

\subsection{Para que serve}

A principal funcionalidade de um trigger é a automatização de tarefas no banco de dados após ocorrer alguma ação.

\subsection{Para que deve ser aplicado}

A aplicação de triggers dependerá muito de como esta sendo desenvolvendo determinada aplicação. O melhor cenário seria quando é necessário tirar algumas funções de uma aplicação e colocá-las no banco de dados, por exemplo. \\
Um exemplo seria o armazenamento de acessos à determinada aplicação, visto que o trigger dispara-rá uma função que vai registrar os dados do usuário visitante (como por exemplo: IP, data de acesso, entre outros dados) e criará um log de usuário, registrando no banco de dados. 

\subsection{Locais onde não deve ser aplicado}

Existem alguns cenários em que se deve analisar a necessidade de utilizar um trigger, ao adota-lo, resultará na quase impossibilidade de migração de banco de dados, visto que os triggers utilizam uma linguagem proprietária. \\
É consenso também que a utilização de triggers acarreta em uma queda de perfmormance.

\subsection{Exemplos práticos}

Para exemplificar na prática o uso de triggers, será usado como cenário uma certa aplicação financeira que contém um controle de caixa e efetua vendas.
Abaixo, serão criadas as tabelas para usar de exemplo.

\begin{verbatim}
    CREATE TABLE CAIXA
    (
        DATA            DATETIME,
        SALDO_INICIAL   DECIMAL(10,2),
        SALDO_FINAL     DECIMAL(10,2)
    )
    GO
    INSERT INTO CAIXA
    VALUES (CONVERT(DATETIME, CONVERT(VARCHAR, GETDATE(), 103)), 100, 100)
    GO
    CREATE TABLE VENDAS
    (
        DATA    DATETIME,
        CODIGO  INT,
        VALOR   DECIMAL(10,2)
    )
    GO
\end{verbatim}

Pelo código abaixo, sempre que forem registradas ou excluídas vendas, essas operações devem ser automaticamente refletidas na tabela de caixa, aumentando ou reduzindo o saldo.

\begin{verbatim}
    CREATE TRIGGER TGR_VENDAS_AI
    ON VENDAS
    FOR INSERT
    AS
    BEGIN
        DECLARE
        @VALOR  DECIMAL(10,2),
        @DATA   DATETIME
        SELECT @DATA = DATA, @VALOR = VALOR FROM INSERTED
        UPDATE CAIXA SET SALDO_FINAL = SALDO_FINAL + @VALOR
        WHERE DATA = @DATA
    END
    GO
\end{verbatim}

No exemplo acima, o trigger reflete diretamente sobre a tabela de vendas, que reduzirá o saldo final do caixa na data da venda quando uma venda for inserida. \\
O resultado será mostrado na tabela abaixo:

\begin{table}[htbp]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{DATA}           & \textbf{SALDO\_INICIAL} & \textbf{SALDO\_FINAL} \\ \hline
2022-06-29 00:00:00.000 & 100.00                  & 100.00                \\ \hline
\end{tabular}
\end{table}

% --- Tópico: Procedimentos
\section{Procedimentos}

\subsection{Definição}

Procedimentos, basicamente são um conjunto de comandos em SQL que podem ser executados de uma única vez (como uma função).

\subsection{Para que serve}

Os procedimentos servem para armazenar tarefas repetitivas e aceitar parâmetros de entrada para que determinada tarefa seja efetuada de acordo com a necessidade individual do usuário.

\subsection{Para que deve ser aplicado}

Os procedimentos ajudam a reduzir o tráfego na rede, melhorar a performance de um banco de dados, criar tarefas agendadas, diminuir riscos, criar rotinas de processamento, entre outras aplicações. \\
Procedimentos devem podem aplicados quando temos várias aplicações escritas em diferentes linguagens, ou rodam em plataformas diferentes, porém executam a mesma função. \\

\subsection{Locais onde não deve ser aplicado}

Os procedimentos, apesar de ser a opção mais rápida em determinadas situações (quando em comparação com um trigger, por exemplo),
eles também tiram muito o controle geral do que esta sendo processado pelo sistema, ou seja, isso pode ser uma desvantagem em determinadas situações.

\subsection{Exemplos práticos}

No exemplo abaixo, é executado uma consulta utilizando um filtro por descrição, em uma tabela específica de um determinado banco de dados.

\begin{verbatim}
    USE BancoDados
    GO
    CREATE PROCEDURE Busca
    @CampoBusca VARCHAR (20)
    AS
    SELECT Codigo, Descrição
    FROM NomeTabela
    WHERE Descricao = @CampoBusca
\end{verbatim}

Para executar esse procedimento, basta declarar ''EXECUTE'' seguido pelo nome dele, e na frente o valor a ser utilizado como parâmetro.

\begin{verbatim}
    EXECUTE Busca 'Exemplo'
\end{verbatim}

Para excluir um procedimento, basta utilizar a cláusula ''DROP PROCEDURE'' como no exemplo abaixo.

\begin{verbatim}
    DROP PROCEDURE Busca
\end{verbatim}

% --- Tópico: Joins
\section{Joins}

\subsection{Definição}

Joins são métodos de “Junção”, que tem a finalidade de unir duas tabelas do banco de dados.

\subsection{Para que serve}

Como o própio nome sugere, o método Join serve para juntar tabelas.
Pode-se dizer que o método Join se retrata na Teoria dos Conjuntos, muito conhecida na matemática. \\
Existem vários tipos de comandos ''join'', e cada um possui um efeito diferente em cima das tabelas selecionadas.

\begin{figure}[H]
\caption{Inner Join}
\centering
\includegraphics[width=5cm]{assets/innerJoin.jpg}
\label{fig:innerJoin}
\end{figure}

O Inner Join é o método de junção mais conhecido, e como ilustra a Figura 1, retorna os registros que são comuns às duas tabelas.

\begin{figure}[H]
\caption{Left Join}
\centering
\includegraphics[width=5cm]{assets/leftJoin.jpg}
\label{fig:leftJoin}
\end{figure}

O Left Join, como ilustra a Figura 2, retorna todos os registros que estão na tabela A (mesmo que não estejam na tabela B) e os registros da tabela B que são comuns à tabela A.

\begin{figure}[H]
\caption{Right Join}
\centering
\includegraphics[width=5cm]{assets/rightJoin.jpg}
\label{fig:rightJoin}
\end{figure}

O Right Join, como ilustra a Figura 3, retorna todos os registros que estão na tabela B (mesmo que não estejam na tabela A) e os registros da tabela A que são comuns à tabela B.

\begin{figure}[H]
\caption{Outer Join}
\centering
\includegraphics[width=5cm]{assets/outerJoin.jpg}
\label{fig:outerJoin}
\end{figure}

O Outer Join, como ilustra a Figura 4, retorna todos os registros que estão na tabela A e todos os registros da tabela B.

\begin{figure}[H]
\caption{Left Excluding Join}
\centering
\includegraphics[width=5cm]{assets/leftExcludingJoin.jpg}
\label{fig:leftExcluidingJoin}
\end{figure}

O Left Excluding Join, como ilustra a figura 5, retorna todos os registros que estão na tabela A e que não estejam na tabela B.

\begin{figure}[H]
\caption{Right Excluding Join}
\centering
\includegraphics[width=5cm]{assets/rightExcludingJoin.jpg}
\label{fig:rightExcluidingJoin}
\end{figure}

O Right Excluding Join, como ilustra a Figura 6, retorna todos os registros que estão na tabela B e que não estejam na tabela A.

\begin{figure}[H]
\caption{Outer Excluding Join}
\centering
\includegraphics[width=5cm]{assets/outerExcludingJoin.jpg}
\label{fig:outerExcluidingJoin}
\end{figure}

O Outer Excluding Join, como ilustra a Figura 7, retorna todos os registros que estão na tabela B, mas que não estejam na tabela A, e todos os registros que estão na tabela A, mas que não estejam na tabela B.

\subsection{Para que deve ser aplicado}

Em resumo, os joins servem para qualquer tipo de junção de tabelas. Há diversos usos para a aplicação de joins, mas para isso, deve se saber utilizar o tipo adequado para um query, por exemplo, pois pode resultar em um retorno diferente do esperado, além de gerar até problemas de performance no banco de dados.

\subsection{Locais onde não deve ser aplicado}

Pode se resultar em um problema de performance a utilização do join onde não é necessário seu uso, pois basicamente ele é um mecanismo automático que pode buscar coisas que você o usuário precisa.
Quanto mais há tabelas envolvidas, mais pode prejudicar a performance, até mesmo de forma exponencial. Na prática, quanto mais tabelas, mais combinações são possíveis, mais dados serão gerados, mais fontes a serem consultadas, e se resulta em menos oportunidades de otimizações.

\subsection{Exemplos práticos}

Abaixo será mostrado, em exemplos, o funcionamento e o retorno de cada join, em tabelas previamente montadas, que possuam algum relacionamento para que os dados possam ser ''cruzados''.
Serão criadas duas tabelas contendo uma coluna Nome, que será comum entre elas.

\begin{verbatim}
    CREATE TABLE TabelaA(
      Nome varchar(50) NULL
    )
    GO
    CREATE TABLE TabelaB(
      Nome varchar(50) NULL
\end{verbatim}

Em seguida, serão adicionados, nas tabelas recém criadas, alguns dados para que permitam colocar à prova as junções.

\begin{verbatim}
    INSERT INTO TabelaA VALUES('Fernanda')
    INSERT INTO TabelaA VALUES('Josefa')
    INSERT INTO TabelaA VALUES('Luiz')
    INSERT INTO TabelaA VALUES('Fernando')
    
    INSERT INTO TabelaB VALUES('Carlos')
    INSERT INTO TabelaB VALUES('Manuel')
    INSERT INTO TabelaB VALUES('Luiz')
    INSERT INTO TabelaB VALUES('Fernando')
\end{verbatim}

- Exemplo de junção com o comando Inner Join:

\begin{verbatim}
    SELECT a.Nome, b.Nome
    FROM TabelaA as A
    INNER JOIN TabelaB as B
                    on a.Nome = b.Nome
\end{verbatim}

Resultado:

\begin{table}[htbp]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Nome} & \textbf{Nome} \\ \hline
Luiz          & NULL          \\ \hline
Fernando      & NULL          \\ \hline
\end{tabular}
\end{table}

- Exemplo de junção com o comando Left Join:

\begin{verbatim}
    SELECT a.Nome, b.Nome
    FROM TabelaA as A
    LEFT JOIN TabelaB as B
      on a.Nome = b.Nome
\end{verbatim}

Resultado:

\begin{table}[htbp]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Nome} & \textbf{Nome} \\ \hline
Fernanda      & NULL          \\ \hline
Josefa        & NULL          \\ \hline
Luiz          & Luiz          \\ \hline
Fernando      & Fernando      \\ \hline
\end{tabular}
\end{table}

- Exemplo de junção com o comando Right Join:

\begin{verbatim}
    SELECT a.Nome, b.Nome
    FROM TabelaA as A
    RIGHT JOIN TabelaB as B
      on a.Nome = b.Nome
\end{verbatim}

Resultado:

\begin{table}[htbp]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Nome} & \textbf{Nome} \\ \hline
NULL          & Carlos        \\ \hline
NULL          & Manuel        \\ \hline
Luiz          & Luiz          \\ \hline
Fernando      & Fernando      \\ \hline
\end{tabular}
\end{table}

- Exemplo de junção com o comando Outer Join:

\begin{verbatim}
    SELECT a.Nome, b.Nome
    FROM TabelaA as A
    FULL OUTER JOIN TabelaB as B
        on a.Nome = b.Nome
\end{verbatim}

Resultado:

\begin{table}[htbp]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Nome} & \textbf{Nome} \\ \hline
Fernanda      & NULL          \\ \hline
Josefa        & NULL          \\ \hline
Luiz          & Luiz          \\ \hline
Fernando      & Fernando      \\ \hline
NULL          & Carlos        \\ \hline
NULL          & Manuel        \\ \hline
\end{tabular}
\end{table}

*Observação: nesse código, a palavra reservada OUTER é opcional. Portanto, se a removermos, deixando apenas a expressão FULL JOIN, o resultado será o mesmo.

\vspace{\onelineskip}

- Exemplo de junção com o comando Left Excluding Join:

\begin{verbatim}
    SELECT a.Nome, b.Nome
    FROM TabelaA as A
    LEFT JOIN TabelaB as B
                    on a.Nome = b.Nome
    WHERE b.Nome is null
\end{verbatim}

Resultado:

\begin{table}[htbp]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Nome} & \textbf{Nome} \\ \hline
Fernanda      & NULL          \\ \hline
Josefa        & NULL          \\ \hline
\end{tabular}
\end{table}

- Exemplo de junção com o comando Right Excluding Join:

\begin{verbatim}
    SELECT a.Nome, b.Nome
    FROM TabelaA as A
    RIGHT JOIN TabelaB as B
        on a.Nome = b.Nome
    WHERE a.Nome is null
\end{verbatim}

Resultado:

\begin{table}[htbp]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Nome} & \textbf{Nome} \\ \hline
NULL          & Carlos        \\ \hline
NULL          & Manuel        \\ \hline
\end{tabular}
\end{table}

- Exemplo de junção com o comando Outer Excluding Join:

\begin{verbatim}
    SELECT a.Nome, b.Nome
    FROM TabelaA as A
    FULL OUTER JOIN TabelaB as B
        on a.Nome = b.Nome
    WHERE a.Nome is null or b.Nome is null
\end{verbatim}

Resultado:

\begin{table}[htbp]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Nome} & \textbf{Nome} \\ \hline
Fernanda      & NULL          \\ \hline
Josefa        & NULL          \\ \hline
NULL          & Carlos        \\ \hline
NULL          & Manuel        \\ \hline
\end{tabular}
\end{table}

% --- Conclusão
\section{Considerações finais}

Como visto nesse artigo científico, as aplicações de views, triggers, procedimentos e joins são recursos importantes a serem implementados em um banco de dados, pois eles simplificam diversas operações a serem realizadas por ele.
Assim sendo, se torna mais simples a codificação de um determinado sistema, definindo uma camada intermediária de controle entre o usuário, o banco de dados físico e o código fonte da aplicação.

% --- Referências bibliográficas
\vspace{\onelineskip}
\bibliography{referencias}
\nocite{o-que-e-sql}
\nocite{guia-completo-sql}
\nocite{beaulieu2019aprendendo}
\nocite{conceito-views}
\nocite{microsoft-create-view}
\nocite{triggers-no-sql}
\nocite{trigger-trybe}
\nocite{ibm-procedimentos}
\nocite{introducao-procedimentos}
\nocite{devmedia-joins}
\nocite{devmedia-fulljoins}
\nocite{trybe-join}

% --- Fim do documento
\bookmarksetup{startatroot}

\end{document}